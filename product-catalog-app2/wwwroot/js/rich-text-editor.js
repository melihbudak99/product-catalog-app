/**
 * Rich Text Editor - Professional Grade
 * Microsoft Word HTML Sanitization & Multi-Mode Support
 * 
 * @version 2.0.0
 * @author Product Catalog System
 * @description Professional rich text editor with HTML sanitization, mode switching, and Word compatibility
 */

// Protective wrapper against Chrome extension errors
(function() {
    'use strict';
    
    // Configuration
    const DEBUG_MODE = false; // Set to false for production
    
    // Centralized logging system
    const Logger = {
        debug: (msg, data = null) => DEBUG_MODE && console.log(`üîß RTE: ${msg}`, data || ''),
        info: (msg, data = null) => DEBUG_MODE && console.log(`‚ÑπÔ∏è RTE: ${msg}`, data || ''),
        warn: (msg, data = null) => console.warn(`‚ö†Ô∏è RTE: ${msg}`, data || ''),
        error: (msg, data = null) => console.error(`‚ùå RTE: ${msg}`, data || ''),
        success: (msg, data = null) => DEBUG_MODE && console.log(`‚úÖ RTE: ${msg}`, data || '')
    };
    
    // Handle potential Chrome extension message channel errors
    window.addEventListener('error', function(event) {
        const message = event.message || '';
        if (message.includes('message channel closed') || 
            message.includes('Extension context invalidated')) {
            event.preventDefault();
            return false;
        }
    });
})();

// Global deƒüi≈ükenler
let editorInstance = null;
let isPasteInProgress = false;

class RichTextEditor {
    constructor() {
        this.editor = null;
        this.textarea = null;
        this.isInitialized = false;
        this.eventListeners = [];
        this.savedCursorPosition = null; // Cursor pozisyonunu kaydetmek i√ßin
        
        // Mode switching elements
        this.previewElement = null;
        this.sourceElement = null;
        this.sourceTextarea = null;
        this.currentMode = 'visual'; // 'visual', 'preview', 'source'
        
        // Performance optimization flags
        this._isUpdatingButtons = false;
        this._updateTimeout = null;
        this._charCountTimeout = null;
    }

    // Debounce utility for performance optimization
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func.call(this, ...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Debounced character counter update
    get debouncedCharacterCounter() {
        if (!this._debouncedCharCounter) {
            this._debouncedCharCounter = this.debounce(() => {
                this.updateCharacterCounter();
            }, 150);
        }
        return this._debouncedCharCounter;
    }

    // Cursor pozisyonunu kaydet
    saveCursorPosition() {
        const sel = window.getSelection();
        if (sel.rangeCount > 0) {
            this.savedCursorPosition = sel.getRangeAt(0).cloneRange();
            Logger.debug('Cursor pozisyonu kaydedildi');
            return true;
        }
        return false;
    }

    // Cursor pozisyonunu geri y√ºkle
    restoreCursorPosition() {
        if (this.savedCursorPosition) {
            try {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(this.savedCursorPosition);
                Logger.debug('Cursor pozisyonu geri y√ºklendi');
                return true;
            } catch (e) {
                Logger.warn('Cursor pozisyonu geri y√ºklenemedi', e.message);
                this.savedCursorPosition = null;
                return false;
            }
        }
        return false;
    }

    // Cursor pozisyonunu temizle
    clearSavedCursorPosition() {
        this.savedCursorPosition = null;
    }

    // Ana ba≈ülatma fonksiyonu - Performance & Security Enhanced
    initialize() {
        if (this.isInitialized) {
            Logger.info('Rich text editor zaten ba≈ülatƒ±lmƒ±≈ü');
            return true;
        }

        // Security: DOM element validation
        this.editor = document.getElementById('editor-content');
        this.textarea = document.getElementById('Description');
        this.previewElement = document.getElementById('editor-preview');
        this.sourceElement = document.getElementById('editor-source');
        this.sourceTextarea = document.getElementById('source-textarea');

        if (!this.editor || !this.textarea || !this.previewElement || !this.sourceElement || !this.sourceTextarea) {
            Logger.error('Critical: Editor elements bulunamadƒ± - DOM hazƒ±r deƒüil');
            return false;
        }

        // Security: XSS prevention check
        if (this.editor.classList.contains('rte-active')) {
            Logger.debug('Editor zaten aktif - duplicate initialization prevented');
            return true;
        }

        // Performance: Batch DOM operations
        try {
            this.setupEditor();
        this.setupToolbar();
        this.setupEventListeners();
        this.setupSourceTextareaListener();
        this.loadInitialContent();
        this.updateButtonStates();
        this.updateCharacterCounter(); // ƒ∞lk karakter sayƒ±sƒ±nƒ± ayarla

            this.isInitialized = true;
            this.editor.classList.add('rte-active');
            
            Logger.success('Rich Text Editor ba≈üarƒ±yla ba≈ülatƒ±ldƒ±');
            return true;
            
        } catch (error) {
            Logger.error('Rich Text Editor initialization failed', error.message);
            
            // Fallback: Basic textarea i≈ülevselliƒüi
            if (this.textarea) {
                this.textarea.style.display = 'block';
                Logger.debug('Fallback: Basic textarea enabled');
            }
            
            return false;
        }
    }

    // Editor temel ayarlarƒ±nƒ± yap
    setupEditor() {
        this.editor.contentEditable = true;
        this.editor.spellcheck = false;
        
        // Stil ayarlarƒ±
        Object.assign(this.editor.style, {
            minHeight: '250px',
            padding: '20px',
            border: 'none',
            fontSize: '15px',
            lineHeight: '1.7',
            outline: 'none',
            fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
            backgroundColor: '#fff',
            color: '#333',
            maxHeight: '500px',
            overflowY: 'auto'
        });
    }

    // Toolbar buttonlarƒ±nƒ± ayarla
    setupToolbar() {
        const toolbar = document.querySelector('.editor-toolbar');
        if (!toolbar) return;

        const buttons = toolbar.querySelectorAll('.editor-btn');
        buttons.forEach(button => {
            const command = button.getAttribute('data-command');
            const value = button.getAttribute('data-value');
            const mode = button.getAttribute('data-mode');
            
            // √ñnceki listener'larƒ± temizle
            const newButton = button.cloneNode(true);
            button.parentNode.replaceChild(newButton, button);
            
            this.addEventListener(newButton, 'click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (mode) {
                    // Mode switching
                    this.switchMode(mode);
                } else if (command === 'heading') {
                    this.toggleHeading(value);
                } else if (command) {
                    // Only execute command if command exists
                    this.executeCommand(command, value);
                }
            });
        });
    }

    // Event listener'larƒ± kur
    setupEventListeners() {
        // Debounced button states update - Performance optimized
        this.debouncedUpdateButtonStates = this.debounce(() => {
            this._doUpdateButtonStates();
        }, 100); // Optimize edildi: 150ms -> 100ms

        // ƒ∞√ßerik deƒüi≈üimi - optimized
        this.addEventListener(this.editor, 'input', () => {
            this.updateTextarea();
            this.handlePlaceholder();
            this.debouncedUpdateButtonStates(); // üöÄ Optimized: Debounced version
        });

        // Akƒ±llƒ± yapƒ±≈ütƒ±rma - daha g√º√ßl√º event handling ve async error prevention
        this.addEventListener(this.editor, 'paste', (e) => {
            this.handlePaste(e);
        }, { capture: true, passive: false });
        
        // Ek koruma katmanlarƒ± - Simplified to prevent async issues
        this.addEventListener(this.editor, 'beforepaste', (e) => {
            if (isPasteInProgress) {
                console.log('‚è∏Ô∏è BeforePaste engelliyor');
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, { capture: true, passive: false });

        // Focus/Blur
        this.addEventListener(this.editor, 'focus', () => {
            this.handleFocus();
        });

        this.addEventListener(this.editor, 'blur', () => {
            this.handleBlur();
        });

        // Klavye kƒ±sayollarƒ±
        this.addEventListener(this.editor, 'keydown', (e) => {
            this.handleKeydown(e);
        });

        // Button state g√ºncellemesi - optimized with smart throttling
        let lastUpdateTime = 0;
        const THROTTLE_DELAY = 150;
        
        const throttledUpdate = () => {
            const now = Date.now();
            if (now - lastUpdateTime > THROTTLE_DELAY) {
                lastUpdateTime = now;
                this.debouncedUpdateButtonStates();
            }
        };

        this.addEventListener(this.editor, 'mouseup', throttledUpdate);
        this.addEventListener(this.editor, 'keyup', throttledUpdate);
        this.addEventListener(this.editor, 'selectionchange', throttledUpdate, { passive: true });
    }

    // Event listener y√∂netimi - Enhanced error handling
    addEventListener(element, event, handler, options = {}) {
        try {
            // Default options to prevent async issues
            const safeOptions = {
                passive: false,
                once: false,
                ...options
            };
            
            element.addEventListener(event, handler, safeOptions);
            this.eventListeners.push({ element, event, handler, options: safeOptions });
        } catch (error) {
            console.error('Error adding event listener:', error);
        }
    }

    // Yapƒ±≈ütƒ±rma i≈ülemi - Cursor pozisyonu d√ºzeltildi
    handlePaste(e) {
        if (isPasteInProgress) {
            console.log('‚è∏Ô∏è Yapƒ±≈ütƒ±rma zaten devam ediyor - engelliyor');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
        }

        console.log('üìã Paste event ba≈ülatƒ±ldƒ±');
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        // Mevcut selection/cursor pozisyonunu kaydet
        const sel = window.getSelection();
        if (sel.rangeCount > 0) {
            this.savedCursorPosition = sel.getRangeAt(0).cloneRange();
            console.log('üìç Cursor pozisyonu kaydedildi - startContainer:', this.savedCursorPosition.startContainer.nodeName, 'startOffset:', this.savedCursorPosition.startOffset);
        } else {
            console.log('‚ö†Ô∏è Aktif cursor pozisyonu bulunamadƒ±');
            this.savedCursorPosition = null;
        }
        
        // Global flag'i set et
        isPasteInProgress = true;
        console.log('üö© Paste flag set edildi');

        const clipboardData = e.clipboardData || window.clipboardData;
        const plainText = clipboardData.getData('text/plain') || '';
        const htmlText = clipboardData.getData('text/html') || '';

        console.log('üìä Paste verisi - Plain:', plainText.length, 'chars, HTML:', htmlText.length, 'chars');

        // HTML i√ßeriƒüi varsa ve farklƒ±ysa modal g√∂ster
        if (htmlText && htmlText.trim() !== plainText.trim() && plainText.trim()) {
            this.showPasteModal(htmlText, plainText);
        } else if (plainText.trim()) {
            console.log('üìù D√ºz metin olarak yapƒ±≈ütƒ±rƒ±lƒ±yor');
            this.insertPlainText(plainText);
            this.resetPasteFlag();
        } else {
            console.log('‚ö†Ô∏è Bo≈ü i√ßerik - i≈ülem iptal');
            this.resetPasteFlag();
        }
        
        return false;
    }

    // Yapƒ±≈ütƒ±rma modalƒ±
    showPasteModal(htmlContent, plainText) {
        const existingModal = document.getElementById('paste-modal');
        if (existingModal) {
            existingModal.remove();
        }

        const modal = document.createElement('div');
        modal.id = 'paste-modal';
        modal.className = 'paste-modal-backdrop';
        
        modal.innerHTML = `
            <div class="paste-modal">
                <div class="paste-modal-header">
                    <h3><i class="fas fa-paste"></i> Yapƒ±≈ütƒ±rma Se√ßenekleri</h3>
                    <p>ƒ∞√ßeriƒüi nasƒ±l yapƒ±≈ütƒ±rmak istiyorsunuz?</p>
                </div>
                <div class="paste-modal-body">
                    <div class="paste-option" data-action="keep-format">
                        <div class="paste-option-icon">
                            <i class="fas fa-magic"></i>
                        </div>
                        <div class="paste-option-content">
                            <h4>Bi√ßimi Koru</h4>
                            <p>Metnin formatƒ±nƒ± (kalƒ±n, italik, ba≈ülƒ±k vb.) koruyarak yapƒ±≈ütƒ±r</p>
                            <div class="paste-preview" id="html-preview"></div>
                        </div>
                    </div>
                    <div class="paste-option" data-action="plain-text">
                        <div class="paste-option-icon">
                            <i class="fas fa-font"></i>
                        </div>
                        <div class="paste-option-content">
                            <h4>Sadece Metin</h4>
                            <p>T√ºm formatlarƒ± temizleyerek d√ºz metin olarak yapƒ±≈ütƒ±r</p>
                            <div class="paste-preview" id="text-preview"></div>
                        </div>
                    </div>
                </div>
                <div class="paste-modal-footer">
                    <button class="paste-btn paste-btn-cancel">ƒ∞ptal</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // √ñnizlemeleri doldur
        const htmlPreview = modal.querySelector('#html-preview');
        const textPreview = modal.querySelector('#text-preview');
        
        if (htmlPreview) {
            const cleanHtml = this.sanitizeHtml(htmlContent);
            htmlPreview.innerHTML = cleanHtml.substring(0, 200) + (cleanHtml.length > 200 ? '...' : '');
        }
        
        if (textPreview) {
            textPreview.textContent = plainText.substring(0, 200) + (plainText.length > 200 ? '...' : '');
        }

        // Event handler'lar
        modal.addEventListener('click', (e) => {
            const action = e.target.closest('[data-action]')?.dataset.action;
            
            if (action === 'keep-format') {
                console.log('üé® Bi√ßimi koru se√ßildi');
                // Modal'ƒ± hemen kapat
                modal.remove();
                document.removeEventListener('keydown', escHandler);
                
                // Cursor pozisyonunu geri y√ºkle ve i√ßeriƒüi ekle
                this.insertFormattedContentAtSavedPosition(htmlContent);
                this.resetPasteFlag();
            } else if (action === 'plain-text') {
                console.log('üìù D√ºz metin se√ßildi');
                // Modal'ƒ± hemen kapat
                modal.remove();
                document.removeEventListener('keydown', escHandler);
                
                // Cursor pozisyonunu geri y√ºkle ve i√ßeriƒüi ekle
                this.insertPlainTextAtSavedPosition(plainText);
                this.resetPasteFlag();
            } else if (e.target.classList.contains('paste-btn-cancel') || e.target.closest('.paste-btn-cancel')) {
                console.log('‚ùå Yapƒ±≈ütƒ±rma iptal edildi');
                modal.remove();
                document.removeEventListener('keydown', escHandler);
                this.clearSavedCursorPosition(); // Cursor pozisyonunu temizle
                this.resetPasteFlag();
            }
        });

        // ESC ile kapat
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                document.removeEventListener('keydown', escHandler);
                this.clearSavedCursorPosition(); // Cursor pozisyonunu temizle
                this.resetPasteFlag();
            }
        };
        document.addEventListener('keydown', escHandler);

        // Animasyon
        requestAnimationFrame(() => {
            modal.classList.add('show');
        });
    }

    // HTML'i temizle - Microsoft Word etiketlerini ve gereksiz kƒ±sƒ±mlarƒ± kaldƒ±r
    sanitizeHtml(html) {
        // √ñnce HTML'den gereksiz kƒ±sƒ±mlarƒ± temizle
        let cleanedHtml = html;
        
        // 1. Word Fragment temizliƒüi
        cleanedHtml = cleanedHtml.replace(/<!--StartFragment-->|<!--EndFragment-->/g, '');
        cleanedHtml = cleanedHtml.replace(/<html[\s\S]*?<body[^>]*>|<\/body>[\s\S]*?<\/html>/gi, '');
        
        // 2. Microsoft Office class'larƒ±nƒ± temizle (MsoNormal, MsoListParagraph, vb.)
        cleanedHtml = cleanedHtml.replace(/\s*class\s*=\s*["'][^"']*Mso[^"']*["']/gi, '');
        cleanedHtml = cleanedHtml.replace(/\s*class\s*=\s*["'][^"']*["']/g, ''); // T√ºm class attribute'larƒ±nƒ± kaldƒ±r
        
        // 3. Inline stilleri ve style attribute'larƒ±nƒ± temizle
        cleanedHtml = cleanedHtml.replace(/\s*style\s*=\s*["'][^"']*["']/gi, '');
        
        // 4. XML namespace'leri ve Office-specific attribute'larƒ± temizle
        cleanedHtml = cleanedHtml.replace(/\s*xmlns[^=]*="[^"]*"/gi, '');
        cleanedHtml = cleanedHtml.replace(/\s*xml:[^=]*="[^"]*"/gi, '');
        cleanedHtml = cleanedHtml.replace(/\s*data-[^=]*="[^"]*"/g, '');
        
        // 5. Office prefix'li etiketleri temizle (o:p, w:, v: vb.)
        cleanedHtml = cleanedHtml.replace(/<\/?[ovw]:[^>]*>/gi, '');
        
        // 6. Gereksiz bo≈ü satƒ±rlarƒ± ve whitespace'leri temizle
        cleanedHtml = cleanedHtml.replace(/^\s+$/gm, ''); // Sadece whitespace olan satƒ±rlarƒ± kaldƒ±r
        cleanedHtml = cleanedHtml.replace(/\n{3,}/g, '\n\n'); // 3'ten fazla newline'ƒ± 2'ye indir
        
        // 7. Bo≈ü <p> etiketlerini temizle
        cleanedHtml = cleanedHtml.replace(/<p\s*class\s*=\s*["'][^"']*["']\s*><\/p>/gi, '');
        cleanedHtml = cleanedHtml.replace(/<p\s*><\/p>/g, '');
        
        // 8. Ardƒ±≈üƒ±k bo≈ü <p> etiketlerini tek <p></p>'ye √ßevir
        cleanedHtml = cleanedHtml.replace(/(<p><\/p>\s*){2,}/g, '<p></p>');
        
        // 9. DOM ile son temizlik - izin verilen etiketleri kontrol et
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = cleanedHtml;

        // ƒ∞zin verilen etiketler - ba≈ülƒ±k etiketleri dahil
        const allowedTags = ['p', 'br', 'strong', 'b', 'em', 'i', 'u', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
        
        // ƒ∞zin verilmeyen elementleri temizle
        const allElements = tempDiv.querySelectorAll('*');
        allElements.forEach(el => {
            const tagName = el.tagName.toLowerCase();
            
            if (!allowedTags.includes(tagName)) {
                // ƒ∞zin verilmeyen element - i√ßeriƒüi koru, elementi kaldƒ±r
                const parent = el.parentNode;
                while (el.firstChild) {
                    parent.insertBefore(el.firstChild, el);
                }
                parent.removeChild(el);
            } else {
                // ƒ∞zin verilen element - t√ºm attribute'larƒ± temizle
                const attrs = [...el.attributes];
                attrs.forEach(attr => {
                    el.removeAttribute(attr.name);
                });
            }
        });

        // 10. Son temizlik - bo≈ü paragraflarƒ± kaldƒ±r
        const emptyParagraphs = tempDiv.querySelectorAll('p');
        emptyParagraphs.forEach(p => {
            if (!p.textContent.trim() && p.childElementCount === 0) {
                p.remove();
            }
        });

        // 11. Sonucu d√∂nd√ºr
        let result = tempDiv.innerHTML.trim();
        result = result.replace(/(<p><\/p>\s*){2,}/g, '<p></p>'); // Ardƒ±≈üƒ±k bo≈ü paragraflarƒ± tek paragrafla deƒüi≈ütir
        
        return result;
    }

    // Formatlanmƒ±≈ü i√ßeriƒüi kaydedilen cursor pozisyonuna ekle
    insertFormattedContentAtSavedPosition(htmlContent) {
        const cleanHtml = this.sanitizeHtml(htmlContent);
        
        this.insertHtmlAtSavedCursorPosition(cleanHtml);
        this.updateTextarea();
        this.debouncedUpdateButtonStates();
    }

    // D√ºz metin i√ßeriƒüi kaydedilen cursor pozisyonuna ekle
    insertPlainTextAtSavedPosition(text) {
        const lines = text.split('\n').filter(line => line.trim());
        let html = '';
        
        lines.forEach((line, index) => {
            html += `<p>${this.escapeHtml(line.trim())}</p>`;
        });
        
        this.insertHtmlAtSavedCursorPosition(html || `<p>${this.escapeHtml(text)}</p>`);
        this.updateTextarea();
    }

    // Formatlanmƒ±≈ü i√ßeriƒüi ekle
    insertFormattedContent(htmlContent) {
        const cleanHtml = this.sanitizeHtml(htmlContent);
        
        this.insertHtmlAtCursor(cleanHtml);
        this.updateTextarea();
        this.debouncedUpdateButtonStates();
    }

    // D√ºz metin ekle
    insertPlainText(text) {
        console.log('üìù D√ºz metin ekleniyor...');
        const lines = text.split('\n').filter(line => line.trim());
        let html = '';
        
        lines.forEach((line, index) => {
            html += `<p>${this.escapeHtml(line.trim())}</p>`;
        });
        
        this.insertHtmlAtCursor(html || `<p>${this.escapeHtml(text)}</p>`);
        this.updateTextarea();
        
        console.log('‚úÖ D√ºz metin ba≈üarƒ±yla eklendi');
    }

    // HTML'i kaydedilen cursor pozisyonuna ekle
    insertHtmlAtSavedCursorPosition(html) {
        console.log('üìç HTML kaydedilen cursor pozisyonuna ekleniyor:', html.substring(0, 50) + '...');
        
        // Edit√∂r√º focus et
        this.editor.focus();
        
        // Kaydedilen cursor pozisyonu varsa onu kullan
        if (this.savedCursorPosition) {
            console.log('üìç Kaydedilen cursor pozisyonu geri y√ºkleniyor...');
            try {
                // √ñnce mevcut selection'ƒ± temizle
                const sel = window.getSelection();
                sel.removeAllRanges();
                
                // Kaydedilen pozisyonu geri y√ºkle
                const restoredRange = this.savedCursorPosition.cloneRange();
                
                // Range'in hala ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
                if (restoredRange.startContainer.parentNode) {
                    sel.addRange(restoredRange);
                    console.log('‚úÖ Cursor pozisyonu ba≈üarƒ±yla geri y√ºklendi');
                    
                    // HTML'i bu pozisyona ekle
                    this.insertHtmlAtCurrentPosition(html);
                    
                    // Cursor pozisyonunu temizle
                    this.clearSavedCursorPosition();
                    return;
                } else {
                    console.log('‚ö†Ô∏è Kaydedilen cursor pozisyonu artƒ±k ge√ßerli deƒüil');
                }
            } catch (e) {
                console.log('‚ö†Ô∏è Cursor pozisyonu geri y√ºklenemedi:', e);
            }
        }
        
        // Fallback: Normal insertion yap
        console.log('üìç Fallback: Normal insertion kullanƒ±lƒ±yor');
        this.insertHtmlAtCursor(html);
    }

    // HTML'i mevcut cursor pozisyonuna ekle
    insertHtmlAtCurrentPosition(html) {
        console.log('üìç HTML mevcut cursor pozisyonuna ekleniyor...');
        
        const sel = window.getSelection();
        if (!sel.rangeCount) {
            console.log('‚ö†Ô∏è Cursor bulunamadƒ±, edit√∂r√ºn sonuna ekleniyor');
            this.insertAtEnd(html);
            return;
        }
        
        try {
            const range = sel.getRangeAt(0);
            console.log('üìç Aktif cursor pozisyonu bulundu');
            
            // Mevcut se√ßimi sil (eƒüer varsa)
            if (!range.collapsed) {
                range.deleteContents();
                console.log('üóëÔ∏è Se√ßili i√ßerik silindi');
            }

            // HTML'i DOM fragment'ƒ± olarak hazƒ±rla
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            const fragment = document.createDocumentFragment();
            const nodes = [];
            
            // T√ºm node'larƒ± fragment'a ta≈üƒ±
            while (tempDiv.firstChild) {
                const node = tempDiv.firstChild;
                nodes.push(node);
                fragment.appendChild(node);
            }
            
            // Fragment'ƒ± cursor pozisyonuna ekle
            range.insertNode(fragment);
            console.log('‚úÖ Fragment cursor pozisyonuna eklendi');
            
            // Cursor'u eklenen i√ßeriƒüin sonuna konumlandƒ±r
            if (nodes.length > 0) {
                const lastNode = nodes[nodes.length - 1];
                const newRange = document.createRange();
                
                // Son node'un tipine g√∂re cursor pozisyonunu ayarla
                if (lastNode.nodeType === Node.TEXT_NODE) {
                    newRange.setStart(lastNode, lastNode.textContent.length);
                } else if (lastNode.lastChild && lastNode.lastChild.nodeType === Node.TEXT_NODE) {
                    newRange.setStart(lastNode.lastChild, lastNode.lastChild.textContent.length);
                } else {
                    newRange.setStartAfter(lastNode);
                }
                
                newRange.collapse(true);
                sel.removeAllRanges();
                sel.addRange(newRange);
                
                console.log('‚úÖ Cursor eklenen i√ßeriƒüin sonuna konumlandƒ±rƒ±ldƒ±');
            }
            
            console.log('‚úÖ HTML cursor pozisyonuna ba≈üarƒ±yla eklendi');
            
        } catch (error) {
            console.error('‚ùå Cursor pozisyonuna ekleme hatasƒ±:', error);
            // Hata durumunda g√ºvenli fallback
            this.insertAtEnd(html);
        }
        
        this.updateTextarea();
        this.debouncedUpdateButtonStates(); // Optimize edildi (debounced)
        
        // Son kontrol - edit√∂r bo≈üsa placeholder ekle
        setTimeout(() => {
            this.handlePlaceholder();
        }, 50);
    }

    // HTML'i cursor pozisyonuna temiz bir ≈üekilde ekle
    insertHtmlAtCursor(html) {
        console.log('üìç HTML cursor pozisyonuna ekleniyor:', html.substring(0, 50) + '...');
        
        // Edit√∂r√º focus et
        this.editor.focus();
        
        const sel = window.getSelection();
        
        // Placeholder kontrol√º - sadece ger√ßek placeholder'lar i√ßin
        const currentContent = this.editor.innerHTML.trim();
        const isActuallyEmpty = currentContent === '' || 
                               currentContent === '<p><br></p>' || 
                               currentContent === '<p></p>' || 
                               currentContent === '<br>' ||
                               (currentContent.includes('√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n') && currentContent.length < 100);
        
        // Sadece ger√ßekten bo≈ü veya placeholder i√ßerik varsa temizle
        if (isActuallyEmpty) {
            console.log('üóëÔ∏è Ger√ßek placeholder/bo≈ü i√ßerik tespit edildi - temizleniyor');
            this.editor.innerHTML = html;
            
            // Cursor'u eklenen i√ßeriƒüin sonuna koy
            setTimeout(() => {
                this.setCursorToEnd();
                this.updateTextarea();
                this.debouncedUpdateButtonStates(); // Optimize edildi (debounced)
            }, 10);
            
            console.log('‚úÖ ƒ∞√ßerik placeholder yerine eklendi');
            return;
        }
        
        // Normal i√ßerik var - mevcut cursor pozisyonunu kullan
        console.log('üìç Normal i√ßerik mevcut - cursor pozisyonuna ekleniyor...');
        
        if (!sel.rangeCount) {
            console.log('‚ö†Ô∏è Cursor bulunamadƒ±, edit√∂r√ºn sonuna ekleniyor');
            this.insertAtEnd(html);
            return;
        }
        
        try {
            const range = sel.getRangeAt(0);
            console.log('üìç Aktif cursor pozisyonu bulundu');
            
            // Mevcut se√ßimi sil (eƒüer varsa)
            if (!range.collapsed) {
                range.deleteContents();
                console.log('üóëÔ∏è Se√ßili i√ßerik silindi');
            }

            // HTML'i DOM fragment'ƒ± olarak hazƒ±rla
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            const fragment = document.createDocumentFragment();
            const nodes = [];
            
            // T√ºm node'larƒ± fragment'a ta≈üƒ±
            while (tempDiv.firstChild) {
                const node = tempDiv.firstChild;
                nodes.push(node);
                fragment.appendChild(node);
            }
            
            // Fragment'ƒ± cursor pozisyonuna ekle
            range.insertNode(fragment);
            console.log('‚úÖ Fragment cursor pozisyonuna eklendi');
            
            // Cursor'u eklenen i√ßeriƒüin sonuna konumlandƒ±r
            if (nodes.length > 0) {
                const lastNode = nodes[nodes.length - 1];
                const newRange = document.createRange();
                
                // Son node'un tipine g√∂re cursor pozisyonunu ayarla
                if (lastNode.nodeType === Node.TEXT_NODE) {
                    newRange.setStart(lastNode, lastNode.textContent.length);
                } else if (lastNode.lastChild && lastNode.lastChild.nodeType === Node.TEXT_NODE) {
                    newRange.setStart(lastNode.lastChild, lastNode.lastChild.textContent.length);
                } else {
                    newRange.setStartAfter(lastNode);
                }
                
                newRange.collapse(true);
                sel.removeAllRanges();
                sel.addRange(newRange);
                
                console.log('‚úÖ Cursor eklenen i√ßeriƒüin sonuna konumlandƒ±rƒ±ldƒ±');
            }
            
            console.log('‚úÖ HTML cursor pozisyonuna ba≈üarƒ±yla eklendi');
            
        } catch (error) {
            console.error('‚ùå Cursor pozisyonuna ekleme hatasƒ±:', error);
            // Hata durumunda g√ºvenli fallback
            this.insertAtEnd(html);
        }
        
        this.updateTextarea();
        this.debouncedUpdateButtonStates(); // Optimize edildi (debounced)
        
        // Son kontrol - edit√∂r bo≈üsa placeholder ekle
        setTimeout(() => {
            this.handlePlaceholder();
        }, 50);
    }

    // Cursor'u edit√∂r√ºn ba≈üƒ±na koy
    setCursorToStart() {
        const range = document.createRange();
        const sel = window.getSelection();
        
        this.editor.focus();
        
        if (this.editor.firstChild) {
            // ƒ∞lk child varsa onun ba≈üƒ±na koy
            if (this.editor.firstChild.nodeType === Node.TEXT_NODE) {
                range.setStart(this.editor.firstChild, 0);
            } else {
                range.setStart(this.editor.firstChild, 0);
            }
        } else {
            // Hi√ß child yoksa edit√∂r√ºn kendisinin ba≈üƒ±na koy
            range.setStart(this.editor, 0);
        }
        
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
        
        console.log('üìç Cursor edit√∂r√ºn ba≈üƒ±na konumlandƒ±rƒ±ldƒ±');
    }

    // Cursor'u edit√∂r√ºn sonuna koy
    setCursorToEnd() {
        const range = document.createRange();
        const sel = window.getSelection();
        
        this.editor.focus();
        
        if (this.editor.lastChild) {
            // Son child varsa onun sonuna koy
            if (this.editor.lastChild.nodeType === Node.TEXT_NODE) {
                range.setStart(this.editor.lastChild, this.editor.lastChild.textContent.length);
            } else if (this.editor.lastChild.lastChild && this.editor.lastChild.lastChild.nodeType === Node.TEXT_NODE) {
                range.setStart(this.editor.lastChild.lastChild, this.editor.lastChild.lastChild.textContent.length);
            } else {
                range.setStartAfter(this.editor.lastChild);
            }
        } else {
            // Hi√ß child yoksa edit√∂r√ºn kendisinin sonuna koy
            range.setStart(this.editor, 0);
        }
        
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
        
        console.log('üìç Cursor edit√∂r√ºn sonuna konumlandƒ±rƒ±ldƒ±');
    }

    // G√ºvenli fallback - edit√∂r√ºn sonuna ekle
    insertAtEnd(html) {
        console.log('üîÑ Fallback: ƒ∞√ßerik edit√∂r√ºn sonuna ekleniyor');
        
        if (this.editor.innerHTML.trim() === '' || this.editor.innerHTML.includes('√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n')) {
            this.editor.innerHTML = html;
        } else {
            this.editor.innerHTML += html;
        }
        
        // Cursor'u sona koy
        this.setCursorToEnd();
        
        // Cursor pozisyonunu temizle
        this.clearSavedCursorPosition();
    }

    // HTML escape
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Paste flag'i sƒ±fƒ±rla - Optimized version
    resetPasteFlag() {
        console.log('üîÑ Paste flag sƒ±fƒ±rlanƒ±yor...');
        isPasteInProgress = false;
        
        // Single safety timeout - optimized from 3 timeouts to 1
        setTimeout(() => {
            isPasteInProgress = false;
            console.log('‚úÖ Paste flag kesin olarak sƒ±fƒ±rlandƒ±');
        }, 200); // Optimized: Single timeout with reasonable delay
    }

    // Komut √ßalƒ±≈ütƒ±r
    executeCommand(command, value = null) {
        if (!command) {
            console.warn('‚ö†Ô∏è executeCommand: Command is null or undefined');
            return;
        }
        
        this.editor.focus();
        
        try {
            if (command === 'heading') {
                this.toggleHeading(value);
            } else if (command === 'indent') {
                this.indentContent();
            } else if (command === 'outdent') {
                this.outdentContent();
            } else if (command === 'removeFormat') {
                this.clearFormatting();
            } else {
                const success = document.execCommand(command, false, value);
                // Debug log removed for production
            }
            
            this.updateTextarea();
            this.debouncedUpdateButtonStates(); // Optimize edildi (debounced)
        } catch (error) {
            console.error('Komut hatasƒ±:', error);
        }
    }

    // Ba≈ülƒ±k toggle - Ger√ßek toggle mekanizmasƒ±
    toggleHeading(tagName) {
        console.log(`üìù Ba≈ülƒ±k toggle √ßalƒ±≈ütƒ±rƒ±lƒ±yor: ${tagName}`);
        
        this.editor.focus();
        
        try {
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                console.log('‚ö†Ô∏è Se√ßim bulunamadƒ±');
                return;
            }
            
            // Mevcut elementi bul
            let currentElement = selection.anchorNode;
            if (currentElement.nodeType === 3) { // Text node
                currentElement = currentElement.parentElement;
            }
            
            // En yakƒ±n blok elementi bul
            while (currentElement && currentElement !== this.editor && 
                   !['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div'].includes(currentElement.tagName?.toLowerCase())) {
                currentElement = currentElement.parentElement;
            }
            
            if (!currentElement || currentElement === this.editor) {
                console.log('üîß Blok element bulunamadƒ±, p etiketi olu≈üturuluyor');
                document.execCommand('formatBlock', false, 'p');
                // Yeni olu≈üan elementi bul
                const newSelection = window.getSelection();
                if (newSelection.anchorNode) {
                    currentElement = newSelection.anchorNode.nodeType === 3 ? 
                        newSelection.anchorNode.parentElement : newSelection.anchorNode;
                }
            }
            
            const currentTag = currentElement.tagName?.toLowerCase();
            console.log(`üîç Mevcut element: ${currentTag}`);
            
            if (currentTag === tagName.toLowerCase()) {
                // Aynƒ± ba≈ülƒ±k etiketi - P'ye d√∂n√º≈üt√ºr (toggle OFF)
                console.log(`üîÑ ${tagName.toUpperCase()} zaten aktif ‚Üí Normal paragrafa d√∂n√º≈üt√ºr√ºl√ºyor`);
                const success = document.execCommand('formatBlock', false, 'p');
                console.log(`‚úÖ formatBlock (p) ba≈üarƒ± durumu: ${success}`);
                
                if (success) {
                    console.log(`‚úÖ ${tagName.toUpperCase()} ba≈ülƒ±ƒüƒ± KALDIRILDI ‚Üí Normal paragraf yapƒ±ldƒ±`);
                    
                    // Button state'i g√ºncelle - Optimize edildi (debounced)
                    this.debouncedUpdateButtonStates();
                }
            } else {
                // Farklƒ± etiket veya p - istenen ba≈ülƒ±ƒüa d√∂n√º≈üt√ºr (toggle ON)
                console.log(`üîÑ ${currentTag || 'undefined'} ‚Üí ${tagName.toUpperCase()} d√∂n√º≈üt√ºr√ºl√ºyor`);
                const success = document.execCommand('formatBlock', false, tagName);
                console.log(`‚úÖ formatBlock (${tagName}) ba≈üarƒ± durumu: ${success}`);
                
                if (success) {
                    console.log(`‚úÖ ${tagName.toUpperCase()} ba≈ülƒ±ƒüƒ± UYGULANDI`);
                    
                    // Button state'i g√ºncelle - Optimize edildi (debounced)
                    this.debouncedUpdateButtonStates();
                }
            }
            
            this.updateTextarea();
            
        } catch (error) {
            console.error(`‚ùå Ba≈ülƒ±k toggle hatasƒ± (${tagName}):`, error);
        }
    }

    // Girinti artƒ±rma (Indent) - Export Uyumlu
    indentContent() {
        console.log('üìù Girinti artƒ±rma i≈ülemi ba≈ülatƒ±lƒ±yor (Export uyumlu)');
        
        try {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            let element = range.commonAncestorContainer;
            
            // Text node ise parent elementi al
            if (element.nodeType === 3) {
                element = element.parentElement;
            }
            
            // En yakƒ±n blok elementi bul (p, li, div, heading)
            while (element && element !== this.editor && 
                   !['p', 'li', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element.tagName?.toLowerCase())) {
                element = element.parentElement;
            }
            
            if (element && element !== this.editor) {
                // Export uyumlu girinti: CSS class kullan
                const currentClass = element.className || '';
                const indentMatch = currentClass.match(/indent-level-(\d+)/);
                const currentLevel = indentMatch ? parseInt(indentMatch[1]) : 0;
                const newLevel = Math.min(currentLevel + 1, 5); // Maksimum 5 seviye
                
                // Eski indent class'ƒ±nƒ± kaldƒ±r
                element.className = currentClass.replace(/indent-level-\d+\s?/g, '');
                
                // Yeni indent class'ƒ±nƒ± ekle
                if (element.className.trim()) {
                    element.className += ` indent-level-${newLevel}`;
                } else {
                    element.className = `indent-level-${newLevel}`;
                }
                
                console.log(`‚úÖ Girinti seviyesi: ${currentLevel} ‚Üí ${newLevel} (CSS class: indent-level-${newLevel})`);
            }
            
        } catch (error) {
            console.error('‚ùå Girinti artƒ±rma hatasƒ±:', error);
        }
    }

    // Girinti azaltma (Outdent) - Export Uyumlu
    outdentContent() {
        console.log('üìù Girinti azaltma i≈ülemi ba≈ülatƒ±lƒ±yor (Export uyumlu)');
        
        try {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            let element = range.commonAncestorContainer;
            
            // Text node ise parent elementi al
            if (element.nodeType === 3) {
                element = element.parentElement;
            }
            
            // En yakƒ±n blok elementi bul (p, li, div, heading)
            while (element && element !== this.editor && 
                   !['p', 'li', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element.tagName?.toLowerCase())) {
                element = element.parentElement;
            }
            
            if (element && element !== this.editor) {
                // Export uyumlu girinti: CSS class kullan
                const currentClass = element.className || '';
                const indentMatch = currentClass.match(/indent-level-(\d+)/);
                const currentLevel = indentMatch ? parseInt(indentMatch[1]) : 0;
                const newLevel = Math.max(0, currentLevel - 1);
                
                // Eski indent class'ƒ±nƒ± kaldƒ±r
                element.className = currentClass.replace(/indent-level-\d+\s?/g, '');
                
                // Yeni indent class'ƒ±nƒ± ekle (eƒüer 0'dan b√ºy√ºkse)
                if (newLevel > 0) {
                    if (element.className.trim()) {
                        element.className += ` indent-level-${newLevel}`;
                    } else {
                        element.className = `indent-level-${newLevel}`;
                    }
                }
                
                // Bo≈ü class attribute'u temizle
                if (!element.className.trim()) {
                    element.removeAttribute('class');
                }
                
                console.log(`‚úÖ Girinti seviyesi: ${currentLevel} ‚Üí ${newLevel}`);
            }
            
        } catch (error) {
            console.error('‚ùå Girinti azaltma hatasƒ±:', error);
        }
    }

    // Bi√ßimlendirmeyi temizleme (Clear Formatting) - Geli≈ümi≈ü
    clearFormatting() {
        try {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            // Eƒüer se√ßim varsa, sadece se√ßili alanƒ± temizle
            if (!selection.isCollapsed) {
                this.clearSelectedFormatting(selection);
            } else {
                this.clearAllFormatting();
            }
            
            // ƒ∞≈ülem sonunda Microsoft Word HTML'ini de temizle
            this.cleanMicrosoftWordHtml();
            
        } catch (error) {
            console.error('‚ùå Bi√ßimlendirme temizleme hatasƒ±:', error);
        }
    }
    
    // Microsoft Word HTML'ini temizle
    cleanMicrosoftWordHtml() {
        const currentContent = this.editor.innerHTML;
        if (currentContent && (currentContent.includes('MsoNormal') || currentContent.includes('class="Mso') || currentContent.includes('microsoft'))) {
            const cleanedContent = this.sanitizeHtml(currentContent);
            this.editor.innerHTML = cleanedContent;
            this.updateTextarea();
        }
    }

    // Se√ßili alanƒ±n formatƒ±nƒ± temizle
    clearSelectedFormatting(selection) {
        try {
            const range = selection.getRangeAt(0);
            const fragment = range.cloneContents();
            
            // Se√ßili i√ßeriƒüin sadece text halini al
            const plainText = this.extractPlainText(fragment);
            
            // Se√ßili alanƒ± sil ve temiz metin ekle
            range.deleteContents();
            
            // Yeni metin node'u olu≈ütur ve ekle
            const textNode = document.createTextNode(plainText);
            range.insertNode(textNode);
            
            // Se√ßimi yeni eklenen metnin sonuna koy
            range.setStartAfter(textNode);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            console.log('‚úÖ Se√ßili alandaki bi√ßimlendirme temizlendi');
            
        } catch (error) {
            console.error('‚ùå Se√ßili alan temizleme hatasƒ±:', error);
        }
    }

    // T√ºm edit√∂r√ºn formatƒ±nƒ± temizle
    clearAllFormatting() {
        try {
            // Cursor pozisyonunu kaydet
            this.saveCursorPosition();
            
            // Edit√∂r√ºn t√ºm text i√ßeriƒüini al
            const plainText = this.extractPlainText(this.editor);
            
            // Temiz paragraflar halinde yeniden d√ºzenle
            const paragraphs = plainText.split(/\n\s*\n/).filter(p => p.trim());
            
            if (paragraphs.length === 0) {
                this.editor.innerHTML = '<p><br></p>';
            } else {
                const cleanHtml = paragraphs
                    .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`)
                    .join('');
                this.editor.innerHTML = cleanHtml;
            }
            
            // Cursor pozisyonunu geri y√ºkle veya sona koy
            setTimeout(() => {
                try {
                    this.restoreCursorPosition();
                } catch (e) {
                    this.setCursorToEnd();
                }
            }, 50);
            
            console.log('‚úÖ T√ºm bi√ßimlendirme temizlendi');
            
        } catch (error) {
            console.error('‚ùå T√ºm edit√∂r temizleme hatasƒ±:', error);
        }
    }

    // Element veya fragment'tan sadece plain text √ßƒ±kar
    extractPlainText(element) {
        if (element.nodeType === Node.TEXT_NODE) {
            return element.textContent || '';
        }
        
        let text = '';
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        let node;
        while (node = walker.nextNode()) {
            text += node.textContent;
        }
        
        return text;
    }

    // Focus i≈üleme
    handleFocus() {
        const container = this.editor.closest('.rich-text-editor');
        if (container) {
            container.style.borderColor = '#667eea';
            container.style.boxShadow = '0 0 0 0.2rem rgba(102, 126, 234, 0.25)';
        }
        
        // Placeholder temizle - ama cursor pozisyonunu koruyarak
        if (this.editor.innerHTML.includes('√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n')) {
            // Mevcut cursor pozisyonunu kaydet
            const sel = window.getSelection();
            const savedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            
            this.editor.innerHTML = '<p></p>';
            this.editor.style.color = '#333';
            
            // Cursor pozisyonunu geri y√ºkle veya uygun konuma yerle≈ütir
            if (savedRange) {
                try {
                    sel.removeAllRanges();
                    sel.addRange(savedRange);
                } catch (e) {
                    // Hata durumunda ilk paragrafƒ±n i√ßine cursor koy
                    const newRange = document.createRange();
                    const firstP = this.editor.querySelector('p');
                    if (firstP) {
                        newRange.setStart(firstP, 0);
                        newRange.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(newRange);
                    }
                }
            } else {
                // Cursor yoksa ilk paragrafƒ±n i√ßine koy
                const newRange = document.createRange();
                const firstP = this.editor.querySelector('p');
                if (firstP) {
                    newRange.setStart(firstP, 0);
                    newRange.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(newRange);
                }
            }
        }
        
        this.debouncedUpdateButtonStates(); // Optimize edildi (debounced)
    }

    // Blur i≈üleme
    handleBlur() {
        const container = this.editor.closest('.rich-text-editor');
        if (container) {
            container.style.borderColor = '#e9ecef';
            container.style.boxShadow = 'none';
        }
        this.updateTextarea();
        this.handlePlaceholder();
    }

    // Klavye kƒ±sayollarƒ±
    handleKeydown(e) {
        // Tab ve Shift+Tab i√ßin girinti kontrolleri
        if (e.key === 'Tab') {
            e.preventDefault();
            if (e.shiftKey) {
                this.executeCommand('outdent');
            } else {
                this.executeCommand('indent');
            }
            return;
        }
        
        if (e.ctrlKey || e.metaKey) {
            switch(e.key.toLowerCase()) {
                case 'b':
                    e.preventDefault();
                    this.executeCommand('bold');
                    break;
                case 'i':
                    e.preventDefault();
                    this.executeCommand('italic');
                    break;
                case 'u':
                    e.preventDefault();
                    this.executeCommand('underline');
                    break;
            }
        }
    }

    // Placeholder y√∂netimi
    handlePlaceholder() {
        const content = this.editor.innerHTML.trim();
        const isEmpty = content === '' || content === '<p><br></p>' || content === '<br>' || content === '<p></p>';
        
        if (isEmpty) {
            this.editor.innerHTML = '<p style="color: #999; font-style: italic;">√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n...</p>';
        }
    }

    // Textarea'yƒ± g√ºncelle - Mode-aware version with auto HTML cleanup
    updateTextarea() {
        if (!this.textarea) return;
        
        let content = '';
        
        // Get content based on current mode
        switch (this.currentMode) {
            case 'visual':
                content = this.editor.innerHTML;
                break;
            case 'source':
                content = this.sourceTextarea.value;
                break;
            case 'preview':
                // Preview mode uses existing textarea content
                return;
        }
        
        // Placeholder temizle
        if (content.includes('√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n')) {
            content = '';
        }
        
        // Microsoft Word HTML'ini otomatik temizle
        if (content && (content.includes('class="MsoNormal"') || content.includes('Mso') || content.includes('microsoft'))) {
            content = this.sanitizeHtml(content);
        }
        
        // Bo≈ü paragraflarƒ± temizle
        if (content === '<p><br></p>' || content === '<p></p>' || content === '<br>') {
            content = '';
        }
        
        this.textarea.value = content;
        
        // Update preview content if needed
        if (this.currentMode !== 'source') {
            this.updatePreviewContent();
        }
        
        // Form validation sistemini tetikle
        this.triggerValidationEvents();
    }

    // Validation event'lerini tetikle
    triggerValidationEvents() {
        if (!this.textarea) return;
        
        // Character counter g√ºncelle (debounced)
        this.debouncedCharacterCounter();
        
        // jQuery validation i√ßin input event
        const inputEvent = new Event('input', { bubbles: true });
        this.textarea.dispatchEvent(inputEvent);
        
        // Change event de tetikle
        const changeEvent = new Event('change', { bubbles: true });
        this.textarea.dispatchEvent(changeEvent);
        
        // jQuery validation manuel tetikleme (eƒüer mevcut ise)
        if (window.jQuery && jQuery(this.textarea).valid) {
            jQuery(this.textarea).valid();
        }
    }

    // Character counter g√ºncelleme - Mode-aware version
    updateCharacterCounter() {
        const counter = document.getElementById('description-char-count');
        if (!counter) return;
        
        let textLength = 0;
        
        // Get text length based on current mode
        switch (this.currentMode) {
            case 'visual':
                textLength = this.extractPlainText(this.editor).length;
                break;
            case 'source':
                textLength = this.extractPlainText(this.sourceTextarea).length;
                break;
            case 'preview':
                textLength = this.extractPlainText(this.editor).length;
                break;
        }
        
        const maxLength = 2000; // Constants.cs'den MAX_DESCRIPTION_LENGTH
        
        counter.textContent = `${textLength}/${maxLength}`;
        
        // Renk kontrolleri
        const counterElement = counter.parentElement;
        const editorContainer = this.editor.closest('.rich-text-editor');
        
        if (textLength > maxLength) {
            // Maksimum a≈üƒ±ldƒ± - kƒ±rmƒ±zƒ±
            counterElement.className = 'description-counter danger';
            editorContainer.classList.add('error');
        } else if (textLength > maxLength * 0.9) {
            // %90'ƒ± a≈ütƒ± - turuncu
            counterElement.className = 'description-counter warning';
            editorContainer.classList.remove('error');
        } else {
            // Normal - gri
            counterElement.className = 'description-counter';
            editorContainer.classList.remove('error');
        }
        
        console.log(`üìä Karakter sayƒ±sƒ± g√ºncellendi: ${textLength}/${maxLength}`);
    }

    // Button durumlarƒ±nƒ± g√ºncelle - Optimize edildi
    updateButtonStates() {
        // Skip if already processing
        if (this._isUpdatingButtons) {
            return;
        }
        
        if (this._updateTimeout) {
            clearTimeout(this._updateTimeout);
        }
        
        this._updateTimeout = setTimeout(() => {
            this._doUpdateButtonStates();
        }, 75); // 50ms -> 75ms optimize edildi
    }
    
    _doUpdateButtonStates() {
        // Performance guard
        if (this._isUpdatingButtons) {
            return;
        }
        
        this._isUpdatingButtons = true;
        
        try {
            const buttons = document.querySelectorAll('.editor-btn');
            
            // √ñnce t√ºm butonlarƒ± sƒ±fƒ±rla - Batch DOM update
            const resetStyles = {
                backgroundColor: '#fff',
                borderColor: '#dee2e6',
                color: '#495057'
            };
            
            buttons.forEach(button => {
                button.classList.remove('active');
                Object.assign(button.style, resetStyles);
            });
            
            // Aktif durumlarƒ± kontrol et (sadece basit komutlar)
            const activeCommands = {
                'bold': document.queryCommandState('bold'),
                'italic': document.queryCommandState('italic'),
                'underline': document.queryCommandState('underline'),
                'insertUnorderedList': document.queryCommandState('insertUnorderedList'),
                'insertOrderedList': document.queryCommandState('insertOrderedList')
            };
            
            // Batch activate buttons
            Object.keys(activeCommands).forEach(command => {
                if (activeCommands[command]) {
                    this.activateButton(command);
                }
            });
            
            // Heading durumlarƒ±nƒ± kontrol et
            this.checkHeadingState();
            
        } catch (error) {
            console.warn('Button state g√ºncelleme hatasƒ±:', error);
        } finally {
            this._isUpdatingButtons = false;
        }
    }

    // Ba≈ülƒ±k durumunu kontrol et - optimize edilmi≈ü
    checkHeadingState() {
        try {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            let element = selection.anchorNode;
            if (!element) return;
            
            // Text node'dan parent element'e ge√ß
            if (element.nodeType === 3) {
                element = element.parentElement;
            }
            
            // En yakƒ±n ba≈ülƒ±k etiketini bul
            let headingFound = false;
            while (element && element !== this.editor && !headingFound) {
                const tagName = element.tagName?.toLowerCase();
                if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {
                    // Sadece deƒüi≈üiklik olduƒüunda log
                    const button = document.querySelector(`[data-command="heading"][data-value="${tagName}"]`);
                    if (button && !button.classList.contains('active')) {
                        console.log(`üìå ${tagName.toUpperCase()} butonu aktif edildi`);
                    }
                    this.activateButton('heading', tagName);
                    headingFound = true;
                }
                element = element.parentElement;
            }
            
            // Eƒüer hi√ßbir ba≈ülƒ±k bulunamazsa, t√ºm ba≈ülƒ±k butonlarƒ±nƒ± deaktif et
            if (!headingFound) {
                const headingButtons = document.querySelectorAll('[data-command="heading"]');
                headingButtons.forEach(button => {
                    if (button.classList.contains('active')) {
                        console.log(`üìå ${button.dataset.value?.toUpperCase()} butonu deaktif edildi`);
                        button.classList.remove('active');
                        button.style.backgroundColor = '#fff';
                        button.style.borderColor = '#dee2e6';
                        button.style.color = '#495057';
                    }
                });
            }
        } catch (error) {
            console.warn('Heading state kontrol√º hatasƒ±:', error);
        }
    }

    // Button'u aktive et - Performance optimized
    activateButton(command, value = null) {
        let selector;
        
        if (command === 'heading' && value) {
            // Heading butonlarƒ± i√ßin √∂zel selector
            selector = `[data-command="heading"][data-value="${value}"]`;
        } else {
            // Normal butonlar i√ßin
            selector = `.editor-btn[data-command="${command}"]`;
        }
        
        const button = document.querySelector(selector);
        if (button && !button.classList.contains('active')) {
            // Batch style update
            button.classList.add('active');
            Object.assign(button.style, {
                backgroundColor: '#667eea',
                borderColor: '#5a6fd8',
                color: '#fff'
            });
        }
    }

    // ƒ∞lk i√ßeriƒüi y√ºkle
    loadInitialContent() {
        if (!this.textarea.value || this.textarea.value.trim() === '') {
            this.editor.innerHTML = '<p style="color: #999; font-style: italic;">√úr√ºn a√ßƒ±klamasƒ±nƒ± buraya yazƒ±n...</p>';
        } else {
            this.editor.innerHTML = this.textarea.value;
        }
        
        // Initialize source textarea with current content
        this.sourceTextarea.value = this.textarea.value || '';
        
        // Initialize preview content
        this.updatePreviewContent();
    }

    // ===== MODE SWITCHING FUNCTIONALITY =====
    
    switchMode(mode) {
        if (this.currentMode === mode) return;
        
        // Save current content before switching
        this.saveCurrentContent();
        
        // Update mode buttons
        this.updateModeButtons(mode);
        
        // Hide all editor areas
        this.editor.style.display = 'none';
        this.previewElement.style.display = 'none';
        this.sourceElement.style.display = 'none';
        
        // Show selected mode
        switch (mode) {
            case 'visual':
                this.editor.style.display = 'block';
                this.enableToolbarButtons(true);
                break;
            case 'preview':
                this.updatePreviewContent();
                this.previewElement.style.display = 'block';
                this.enableToolbarButtons(false);
                break;
            case 'source':
                this.sourceElement.style.display = 'block';
                this.enableToolbarButtons(false);
                this.syncToSourceTextarea();
                break;
        }
        
        this.currentMode = mode;
        // Mode switch completed
    }
    
    saveCurrentContent() {
        switch (this.currentMode) {
            case 'visual':
                this.textarea.value = this.editor.innerHTML;
                break;
            case 'source':
                this.textarea.value = this.sourceTextarea.value;
                this.editor.innerHTML = this.sourceTextarea.value;
                break;
        }
    }
    
    updateModeButtons(activeMode) {
        const modeButtons = document.querySelectorAll('.mode-btn');
        modeButtons.forEach(btn => {
            const mode = btn.getAttribute('data-mode');
            if (mode === activeMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    enableToolbarButtons(enable) {
        const toolbarButtons = document.querySelectorAll('.editor-btn:not(.mode-btn)');
        toolbarButtons.forEach(btn => {
            btn.disabled = !enable;
            btn.style.opacity = enable ? '1' : '0.5';
        });
    }
    
    updatePreviewContent() {
        const content = this.textarea.value || this.editor.innerHTML;
        const previewContent = this.previewElement.querySelector('.preview-content');
        if (previewContent) {
            previewContent.innerHTML = content || '<p style="color: #999; font-style: italic;">√ñnizleme i√ßin i√ßerik yok</p>';
        }
    }
    
    syncToSourceTextarea() {
        this.sourceTextarea.value = this.textarea.value || this.editor.innerHTML;
    }
    
    // Source textarea'dan deƒüi≈üiklikleri dinle
    setupSourceTextareaListener() {
        if (this.sourceTextarea) {
            this.addEventListener(this.sourceTextarea, 'input', () => {
                this.textarea.value = this.sourceTextarea.value;
                this.updateCharacterCounter();
            });
        }
    }
}

// Global fonksiyonlar
function initializeRichTextEditor() {
    if (!editorInstance) {
        editorInstance = new RichTextEditor();
    }
    return editorInstance.initialize();
}

// Global eri≈üim
window.initializeRichTextEditor = initializeRichTextEditor;
